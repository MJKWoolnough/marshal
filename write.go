package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"io"
	"strconv"
	"strings"
)

type pos []int

func (p *pos) newLine() token.Pos {
	l := len(*p)
	*p = append(*p, len(*p), len(*p)+1)

	return token.Pos(l + 1)
}

type constructor struct {
	pkg *types.Package
	pos
	types      map[*types.Named][2]string
	statements []ast.Stmt
}

func constructFile(w io.Writer, pkgName string, assigner, marshaler, unmarshaler, writer, reader string, opts []string, pkg *types.Package, typenames ...string) error {
	var typs []*types.Named

	for _, typename := range typenames {
		typ := pkg.Scope().Lookup(typename)
		if typ == nil {
			return fmt.Errorf("%w: %s", ErrNotFound, typ)
		}

		named, ok := typ.Type().(*types.Named)
		if !ok {
			return fmt.Errorf("%w: %s", ErrNotAType, typename)
		}

		if named.TypeArgs().Len() != 0 {
			return fmt.Errorf("%w: %s", ErrGenericType, typename)
		}

		typs = append(typs, named)
	}

	c := constructor{
		pkg:   pkg,
		pos:   pos{0},
		types: make(map[*types.Named][2]string),
	}
	file := &ast.File{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Slash: c.newLine(),
					Text:  "//go:generate go run vimagination.zapto.org/unsafe@latest " + encodeOpts(opts),
				},
			},
		},
		Name:    ast.NewIdent(pkgName),
		Package: c.newLine(),
		Decls:   c.buildDecls(assigner, marshaler, unmarshaler, writer, reader, typs),
	}
	fset := token.NewFileSet()
	wsfile := fset.AddFile("out.go", 1, len(c.pos))

	wsfile.SetLines(c.pos)

	return format.Node(w, fset, file)
}

func encodeOpts(opts []string) string {
	var buf []byte

	for n, opt := range opts {
		if n > 0 {
			buf = append(buf, ' ')
		}

		if strings.Contains(opt, " ") {
			buf = strconv.AppendQuote(buf, opt)
		} else {
			buf = append(buf, opt...)
		}
	}

	return string(buf)
}

func (c *constructor) buildDecls(assigner, marshaler, unmarshaler, writer, reader string, types []*types.Named) []ast.Decl {
	decls := []ast.Decl{
		c.imports(writer != "" || reader != ""),
	}

	for _, typ := range types {
		typeName := typ.Obj().Name()
		marshalName := marshalName(typ)
		unmarshalName := unmarshalName(typ)
		c.types[typ] = [2]string{marshalName, unmarshalName}

		if assigner != "" {
			decls = append(decls, c.assignBinary(typeName, assigner, marshalName))
		}

		if marshaler != "" {
			decls = append(decls, c.marshalBinary(typeName, marshaler, marshalName))
		}

		if writer != "" {
			decls = append(decls, c.writeTo(typeName, writer, marshalName))
		}

		if unmarshaler != "" {
			decls = append(decls, c.unmarshalBinary(typeName, unmarshaler, unmarshalName))
		}

		if reader != "" {
			decls = append(decls, c.readFrom(typeName, reader, unmarshalName))
		}
	}

	for _, typ := range types {
		if assigner != "" || marshaler != "" || writer != "" {
			decls = append(decls, c.marshalFunc(typ))
		}

		if unmarshaler != "" || reader != "" {
			decls = append(decls, c.unmarshalFunc(typ))
		}
	}

	return decls
}

func marshalName(typ *types.Named) string {
	return "_marshal_" + strings.ReplaceAll(strings.ReplaceAll(typ.Obj().Name(), "_", "__"), ".", "_")
}

func unmarshalName(typ *types.Named) string {
	return "_unmarshal_" + strings.ReplaceAll(strings.ReplaceAll(typ.Obj().Name(), "_", "__"), ".", "_")
}

func (c *constructor) imports(includeStdlib bool) *ast.GenDecl {
	var imports []ast.Spec

	if includeStdlib {
		imports = []ast.Spec{
			&ast.ImportSpec{
				Path: &ast.BasicLit{
					Kind:  token.STRING,
					Value: `"cmp"`,
				},
			},
			&ast.ImportSpec{
				Path: &ast.BasicLit{
					Kind:  token.STRING,
					Value: `"io"`,
				},
			},
		}
	}

	return &ast.GenDecl{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Slash: c.newLine(),
					Text:  "// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT",
				},
			},
		},
		TokPos: c.newLine(),
		Tok:    token.IMPORT,
		Specs: append(imports, &ast.ImportSpec{
			Path: &ast.BasicLit{
				Kind:     token.STRING,
				Value:    `"vimagination.zapto.org/byteio"`,
				ValuePos: c.newLine(),
			},
		}),
	}
}

func (c *constructor) assignBinary(typeName, funcName, marshalName string) *ast.FuncDecl {
	comment := "// AppendBinary implements the encoding.BinaryAppender interface."

	if funcName != "AppendBinary" {
		comment = "// " + funcName + " appends the binary representation of itself to the end of b\n// (allocating a larger slice if necessary) and returns the updated slice."
	}

	return &ast.FuncDecl{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Slash: c.newLine(),
					Text:  comment,
				},
			},
		},
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						ast.NewIdent("t"),
					},
					Type: &ast.UnaryExpr{
						Op: token.MUL,
						X:  ast.NewIdent(typeName),
					},
				},
			},
		},
		Name: &ast.Ident{
			Name: funcName,
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							ast.NewIdent("b"),
						},
						Type: &ast.ArrayType{
							Elt: ast.NewIdent("byte"),
						},
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.ArrayType{
							Elt: ast.NewIdent("byte"),
						},
					},
					{
						Type: ast.NewIdent("error"),
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						ast.NewIdent("eb"),
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("byteio"),
								Sel: ast.NewIdent("MemLittleEndian"),
							},
							Args: []ast.Expr{
								ast.NewIdent("b"),
							},
						},
					},
				},
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						ast.NewIdent("err"),
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: ast.NewIdent(marshalName),
							Args: []ast.Expr{
								ast.NewIdent("t"),
								&ast.UnaryExpr{
									Op: token.AND,
									X:  ast.NewIdent("eb"),
								},
							},
						},
					},
				},
				&ast.ReturnStmt{
					Return: c.newLine(),
					Results: []ast.Expr{
						ast.NewIdent("eb"),
						ast.NewIdent("err"),
					},
				},
			},
		},
	}
}

func (c *constructor) marshalBinary(typeName, funcName, marshalName string) *ast.FuncDecl {
	comment := "// MarshalBinary implements the encoding.BinaryMarshaler interface."

	if funcName != "MarshalBinary" {
		comment = "// " + funcName + " encodes the receiver into a binary form and returns the result."
	}

	return &ast.FuncDecl{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Slash: c.newLine(),
					Text:  comment,
				},
			},
		},
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						ast.NewIdent("t"),
					},
					Type: &ast.UnaryExpr{
						Op: token.MUL,
						X:  ast.NewIdent(typeName),
					},
				},
			},
		},
		Name: &ast.Ident{
			Name: funcName,
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.ArrayType{
							Elt: ast.NewIdent("byte"),
						},
					},
					{
						Type: ast.NewIdent("error"),
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						ast.NewIdent("eb"),
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CompositeLit{
							Type: &ast.SelectorExpr{
								X:   ast.NewIdent("byteio"),
								Sel: ast.NewIdent("MemLittleEndian"),
							},
						},
					},
				},
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						ast.NewIdent("err"),
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: ast.NewIdent(marshalName),
							Args: []ast.Expr{
								ast.NewIdent("t"),
								&ast.UnaryExpr{
									Op: token.AND,
									X:  ast.NewIdent("eb"),
								},
							},
						},
					},
				},
				&ast.ReturnStmt{
					Return: c.newLine(),
					Results: []ast.Expr{
						ast.NewIdent("eb"),
						ast.NewIdent("err"),
					},
				},
			},
		},
	}
}

func (c *constructor) writeTo(typeName, funcName, marshalName string) *ast.FuncDecl {
	comment := "// WriteTo implements the io.WriterTo interface."

	if funcName != "WriteTo" {
		comment = "// " + funcName + " writes data to w until there's no more data to write or when an error occurs.\n//\n// The return value n is the number of bytes written. Any error encountered during the write is also returned."
	}

	return &ast.FuncDecl{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Slash: c.newLine(),
					Text:  comment,
				},
			},
		},
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						ast.NewIdent("t"),
					},
					Type: &ast.UnaryExpr{
						Op: token.MUL,
						X:  ast.NewIdent(typeName),
					},
				},
			},
		},
		Name: &ast.Ident{
			Name: funcName,
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							ast.NewIdent("w"),
						},
						Type: &ast.SelectorExpr{
							X:   ast.NewIdent("io"),
							Sel: ast.NewIdent("Writer"),
						},
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: ast.NewIdent("int64"),
					},
					{
						Type: ast.NewIdent("error"),
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.TypeSwitchStmt{
					Assign: &ast.AssignStmt{
						Lhs: []ast.Expr{
							ast.NewIdent("w"),
						},
						Tok: token.DEFINE,
						Rhs: []ast.Expr{
							&ast.TypeAssertExpr{
								X: ast.NewIdent("w"),
							},
						},
					},
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.CaseClause{
								List: []ast.Expr{
									&ast.UnaryExpr{
										Op: token.MUL,
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("byteio"),
											Sel: ast.NewIdent("MemLittleEndian"),
										},
									},
								},
								Body: []ast.Stmt{
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("l"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent("len"),
												Args: []ast.Expr{
													&ast.UnaryExpr{
														Op: token.MUL,
														X:  ast.NewIdent("w"),
													},
												},
											},
										},
									},
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("err"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent(marshalName),
												Args: []ast.Expr{
													ast.NewIdent("t"),
													ast.NewIdent("w"),
												},
											},
										},
									},
									&ast.ReturnStmt{
										Return: c.newLine(),
										Results: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent("int64"),
												Args: []ast.Expr{
													&ast.BinaryExpr{
														X: &ast.CallExpr{
															Fun: ast.NewIdent("len"),
															Args: []ast.Expr{
																&ast.UnaryExpr{
																	Op: token.MUL,
																	X:  ast.NewIdent("w"),
																},
															},
														},
														Op: token.SUB,
														Y:  ast.NewIdent("l"),
													},
												},
											},
											ast.NewIdent("err"),
										},
									},
								},
							},
							&ast.CaseClause{
								List: []ast.Expr{
									&ast.UnaryExpr{
										Op: token.MUL,
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("byteio"),
											Sel: ast.NewIdent("MemBigEndian"),
										},
									},
								},
								Body: []ast.Stmt{
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("l"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent("len"),
												Args: []ast.Expr{
													&ast.UnaryExpr{
														Op: token.MUL,
														X:  ast.NewIdent("w"),
													},
												},
											},
										},
									},
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("err"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent(marshalName),
												Args: []ast.Expr{
													ast.NewIdent("t"),
													ast.NewIdent("w"),
												},
											},
										},
									},
									&ast.ReturnStmt{
										Return: c.newLine(),
										Results: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent("int64"),
												Args: []ast.Expr{
													&ast.BinaryExpr{
														X: &ast.CallExpr{
															Fun: ast.NewIdent("len"),
															Args: []ast.Expr{
																&ast.UnaryExpr{
																	Op: token.MUL,
																	X:  ast.NewIdent("w"),
																},
															},
														},
														Op: token.SUB,
														Y:  ast.NewIdent("l"),
													},
												},
											},
											ast.NewIdent("err"),
										},
									},
								},
							},
							&ast.CaseClause{
								List: []ast.Expr{
									&ast.UnaryExpr{
										Op: token.MUL,
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("byteio"),
											Sel: ast.NewIdent("StickyLittleEndianWriter"),
										},
									},
								},
								Body: []ast.Stmt{
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("l"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.SelectorExpr{
												X:   ast.NewIdent("w"),
												Sel: ast.NewIdent("Count"),
											},
										},
									},
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											&ast.SelectorExpr{
												X:   ast.NewIdent("w"),
												Sel: ast.NewIdent("Err"),
											},
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: &ast.SelectorExpr{
													X:   ast.NewIdent("cmp"),
													Sel: ast.NewIdent("Or"),
												},
												Args: []ast.Expr{
													&ast.SelectorExpr{
														X:   ast.NewIdent("w"),
														Sel: ast.NewIdent("Err"),
													},
													&ast.CallExpr{
														Fun: ast.NewIdent(marshalName),
														Args: []ast.Expr{
															ast.NewIdent("t"),
															ast.NewIdent("w"),
														},
													},
												},
											},
										},
									},
									&ast.ReturnStmt{
										Return: c.newLine(),
										Results: []ast.Expr{
											&ast.BinaryExpr{
												X: &ast.SelectorExpr{
													X:   ast.NewIdent("w"),
													Sel: ast.NewIdent("Count"),
												},
												Op: token.SUB,
												Y:  ast.NewIdent("l"),
											},
											ast.NewIdent("err"),
										},
									},
								},
							},
							&ast.CaseClause{
								List: []ast.Expr{
									&ast.UnaryExpr{
										Op: token.MUL,
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("byteio"),
											Sel: ast.NewIdent("StickyBigEndianWriter"),
										},
									},
								},
								Body: []ast.Stmt{
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("l"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.SelectorExpr{
												X:   ast.NewIdent("w"),
												Sel: ast.NewIdent("Count"),
											},
										},
									},
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											&ast.SelectorExpr{
												X:   ast.NewIdent("w"),
												Sel: ast.NewIdent("Err"),
											},
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: &ast.SelectorExpr{
													X:   ast.NewIdent("cmp"),
													Sel: ast.NewIdent("Or"),
												},
												Args: []ast.Expr{
													&ast.SelectorExpr{
														X:   ast.NewIdent("w"),
														Sel: ast.NewIdent("Err"),
													},
													&ast.CallExpr{
														Fun: ast.NewIdent(marshalName),
														Args: []ast.Expr{
															ast.NewIdent("t"),
															ast.NewIdent("w"),
														},
													},
												},
											},
										},
									},
									&ast.ReturnStmt{
										Return: c.newLine(),
										Results: []ast.Expr{
											&ast.BinaryExpr{
												X: &ast.SelectorExpr{
													X:   ast.NewIdent("w"),
													Sel: ast.NewIdent("Count"),
												},
												Op: token.SUB,
												Y:  ast.NewIdent("l"),
											},
											ast.NewIdent("err"),
										},
									},
								},
							},
						},
					},
				},
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						&ast.Ident{
							NamePos: c.newLine(),
							Name:    "sw",
						},
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CompositeLit{
							Type: &ast.SelectorExpr{
								X:   ast.NewIdent("byteio"),
								Sel: ast.NewIdent("StickyLittleEndianWriter"),
							},
							Elts: []ast.Expr{
								&ast.KeyValueExpr{
									Key:   ast.NewIdent("Writer"),
									Value: ast.NewIdent("w"),
								},
							},
						},
					},
				},
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						ast.NewIdent("err"),
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("cmp"),
								Sel: ast.NewIdent("Or"),
							},
							Args: []ast.Expr{
								&ast.CallExpr{
									Fun: ast.NewIdent(marshalName),
									Args: []ast.Expr{
										ast.NewIdent("t"),
										&ast.UnaryExpr{
											Op: token.AND,
											X:  ast.NewIdent("sw"),
										},
									},
								},
								&ast.SelectorExpr{
									X:   ast.NewIdent("sw"),
									Sel: ast.NewIdent("Err"),
								},
							},
						},
					},
				},
				&ast.ReturnStmt{
					Return: c.newLine(),
					Results: []ast.Expr{
						&ast.SelectorExpr{
							X:   ast.NewIdent("sw"),
							Sel: ast.NewIdent("Count"),
						},
						ast.NewIdent("err"),
					},
				},
			},
		},
	}
}

func (c *constructor) addStatement(stmt ast.Stmt) {
	c.statements = append(c.statements, stmt)
}

func (c *constructor) writeType(name ast.Expr, typ types.Type) {
	switch t := typ.Underlying().(type) {
	case *types.Struct:
		c.writeStruct(name, t)
	case *types.Array:
		c.writeArray(name, t)
	case *types.Slice:
		c.writeSlice(name, t)
	case *types.Map:
		c.writeMap(name, t)
	case *types.Pointer:
		c.writePointer(name, t)
	case *types.Basic:
		c.writeBasic(name, t)
	}
}

func (c *constructor) writeStruct(name ast.Expr, t *types.Struct) {
	for field := range t.Fields() {
		if !field.Exported() {
			continue
		}

		c.writeType(&ast.SelectorExpr{
			X:   name,
			Sel: ast.NewIdent(field.Name()),
		}, field.Type())
	}
}

func (c *constructor) addWriter(method string, name ast.Expr) {
	c.addCall(&ast.SelectorExpr{
		X:   ast.NewIdent("w"),
		Sel: ast.NewIdent(method),
	}, name)
}

func (c *constructor) subConstructor() *constructor {
	return &constructor{
		pkg:   c.pkg,
		pos:   c.pos,
		types: c.types,
	}
}

func (c *constructor) writeArray(name ast.Expr, t *types.Array) {
	d := c.subConstructor()

	d.writeType(ast.NewIdent("e"), t.Elem())
	c.addStatement(&ast.RangeStmt{
		For:   c.newLine(),
		Key:   ast.NewIdent("_"),
		Value: ast.NewIdent("e"),
		Tok:   token.DEFINE,
		X:     name,
		Body: &ast.BlockStmt{
			List: d.statements,
		},
	})
}

func (c *constructor) writeSlice(name ast.Expr, t *types.Slice) {
	d := c.subConstructor()

	d.writeType(ast.NewIdent("e"), t.Elem())
	c.addWriter("WriteUintX", &ast.CallExpr{
		Fun: ast.NewIdent("uint64"),
		Args: []ast.Expr{
			&ast.CallExpr{
				Fun:  ast.NewIdent("len"),
				Args: []ast.Expr{name},
			},
		},
	})
	c.addStatement(&ast.RangeStmt{
		For:   c.newLine(),
		Key:   ast.NewIdent("_"),
		Value: ast.NewIdent("e"),
		Tok:   token.DEFINE,
		X:     name,
		Body: &ast.BlockStmt{
			List: d.statements,
		},
	})
}

func (c *constructor) writeMap(name ast.Expr, t *types.Map) {
	d := c.subConstructor()

	d.writeType(ast.NewIdent("k"), t.Key())
	d.writeType(ast.NewIdent("v"), t.Elem())
	c.addWriter("WriteUintX", &ast.CallExpr{
		Fun: ast.NewIdent("uint64"),
		Args: []ast.Expr{
			&ast.CallExpr{
				Fun:  ast.NewIdent("len"),
				Args: []ast.Expr{name},
			},
		},
	})
	c.addStatement(&ast.RangeStmt{
		For:   c.newLine(),
		Key:   ast.NewIdent("k"),
		Value: ast.NewIdent("v"),
		Tok:   token.DEFINE,
		X:     name,
		Body: &ast.BlockStmt{
			List: d.statements,
		},
	})
}

func (c *constructor) writePointer(name ast.Expr, t *types.Pointer) {
	d := c.subConstructor()

	d.writeType(name, t.Elem())
	c.addStatement(&ast.ExprStmt{
		X: &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("w"),
				Sel: ast.NewIdent("WriteBool"),
			},
			Args: []ast.Expr{
				&ast.BinaryExpr{
					X:  name,
					Op: token.NEQ,
					Y:  ast.NewIdent("nil"),
				},
			},
		},
	})
	c.addStatement(&ast.IfStmt{
		Cond: &ast.BinaryExpr{
			X:  name,
			Op: token.NEQ,
			Y:  ast.NewIdent("nil"),
		},
		Body: &ast.BlockStmt{
			List: d.statements,
		},
	})
}

func (c *constructor) writeBasic(name ast.Expr, t *types.Basic) {
	switch t.Kind() {
	case types.Bool:
		c.addWriter("WriteBool", name)
	case types.Int:
		c.addWriter("WriteInt64", name)
	case types.Int8:
		c.addWriter("WriteInt8", name)
	case types.Int16:
		c.addWriter("WriteInt16", name)
	case types.Int32:
		c.addWriter("WriteInt32", name)
	case types.Int64:
		c.addWriter("WriteInt64", name)
	case types.Uint:
		c.addWriter("WriteUint64", name)
	case types.Uint8:
		c.addWriter("WriteUint8", name)
	case types.Uint16:
		c.addWriter("WriteUint16", name)
	case types.Uint32:
		c.addWriter("WriteUint32", name)
	case types.Uint64, types.Uintptr:
		c.addWriter("WriteUint64", name)
	case types.Float32:
		c.addWriter("WriteFloat32", name)
	case types.Float64:
		c.addWriter("WriteFloat64", name)
	case types.Complex64:
		c.addWriter("WriteFloat32", &ast.CallExpr{
			Fun:  ast.NewIdent("real"),
			Args: []ast.Expr{name},
		})
		c.addWriter("WriteFloat32", &ast.CallExpr{
			Fun:  ast.NewIdent("imag"),
			Args: []ast.Expr{name},
		})
	case types.Complex128:
		c.addWriter("WriteFloat64", &ast.CallExpr{
			Fun:  ast.NewIdent("real"),
			Args: []ast.Expr{name},
		})
		c.addWriter("WriteFloat64", &ast.CallExpr{
			Fun:  ast.NewIdent("imag"),
			Args: []ast.Expr{name},
		})
	case types.String:
		c.addWriter("WriteStringX", name)
	}
}

func deref(typ types.Type) types.Type {
	if ptr, ok := typ.(*types.Pointer); ok {
		return ptr.Elem()
	}

	return typ
}

func (c *constructor) marshalFunc(typ *types.Named) *ast.FuncDecl {
	typeName := typ.Obj().Name()
	marshalName := marshalName(typ)
	c.statements = nil

	c.writeType(ast.NewIdent("t"), deref(typ.Underlying()))

	return &ast.FuncDecl{
		Name: &ast.Ident{
			Name: marshalName,
		},
		Type: &ast.FuncType{
			Func: c.newLine(),
			TypeParams: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							ast.NewIdent("W"),
						},
						Type: &ast.SelectorExpr{
							X:   ast.NewIdent("byteio"),
							Sel: ast.NewIdent("StickyWriter"),
						},
					},
				},
			},
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							ast.NewIdent("t"),
						},
						Type: &ast.UnaryExpr{
							Op: token.MUL,
							X:  ast.NewIdent(typeName),
						},
					},
					{
						Names: []*ast.Ident{
							ast.NewIdent("w"),
						},
						Type: ast.NewIdent("W"),
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: ast.NewIdent("error"),
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: append(c.statements, &ast.ReturnStmt{
				Return: c.newLine(),
				Results: []ast.Expr{
					ast.NewIdent("nil"),
				},
			}),
		},
	}
}

func (c *constructor) unmarshalBinary(typeName, funcName, unmarshalName string) *ast.FuncDecl {
	comment := "// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface."

	if funcName != "UnmarshalBinary" {
		comment = "// " + funcName + " decodes the receiver from the binary form."
	}

	return &ast.FuncDecl{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Slash: c.newLine(),
					Text:  comment,
				},
			},
		},
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						ast.NewIdent("t"),
					},
					Type: &ast.UnaryExpr{
						Op: token.MUL,
						X:  ast.NewIdent(typeName),
					},
				},
			},
		},
		Name: &ast.Ident{
			Name: funcName,
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{ast.NewIdent("b")},
						Type: &ast.ArrayType{
							Elt: ast.NewIdent("byte"),
						},
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: ast.NewIdent("error"),
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						ast.NewIdent("eb"),
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("byteio"),
								Sel: ast.NewIdent("MemLittleEndian"),
							},
							Args: []ast.Expr{
								ast.NewIdent("b"),
							},
						},
					},
				},
				&ast.ReturnStmt{
					Return: c.newLine(),
					Results: []ast.Expr{
						&ast.CallExpr{
							Fun: ast.NewIdent(unmarshalName),
							Args: []ast.Expr{
								ast.NewIdent("t"),
								&ast.UnaryExpr{
									Op: token.AND,
									X:  ast.NewIdent("eb"),
								},
							},
						},
					},
				},
			},
		},
	}
}

func (c *constructor) readFrom(typeName, funcName, unmarshalName string) *ast.FuncDecl {
	comment := "// ReadFrom implements the io.ReaderFrom interface."

	if funcName != "ReadFrom" {
		comment = "// " + funcName + " reads data from r until the type is fully decoded.\n//\n// The return value n is the number of bytes read. Any error encountered during the read is also returned."
	}

	return &ast.FuncDecl{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Slash: c.newLine(),
					Text:  comment,
				},
			},
		},
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						ast.NewIdent("t"),
					},
					Type: &ast.UnaryExpr{
						Op: token.MUL,
						X:  ast.NewIdent(typeName),
					},
				},
			},
		},
		Name: &ast.Ident{
			Name: funcName,
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							ast.NewIdent("r"),
						},
						Type: &ast.SelectorExpr{
							X:   ast.NewIdent("io"),
							Sel: ast.NewIdent("Reader"),
						},
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: ast.NewIdent("int64"),
					},
					{
						Type: ast.NewIdent("error"),
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.TypeSwitchStmt{
					Assign: &ast.AssignStmt{
						Lhs: []ast.Expr{
							ast.NewIdent("r"),
						},
						Tok: token.DEFINE,
						Rhs: []ast.Expr{
							&ast.TypeAssertExpr{
								X: ast.NewIdent("r"),
							},
						},
					},
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.CaseClause{
								List: []ast.Expr{
									&ast.UnaryExpr{
										Op: token.MUL,
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("byteio"),
											Sel: ast.NewIdent("MemLittleEndian"),
										},
									},
								},
								Body: []ast.Stmt{
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("l"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent("len"),
												Args: []ast.Expr{
													&ast.UnaryExpr{
														Op: token.MUL,
														X:  ast.NewIdent("r"),
													},
												},
											},
										},
									},
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("err"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent(unmarshalName),
												Args: []ast.Expr{
													ast.NewIdent("t"),
													ast.NewIdent("r"),
												},
											},
										},
									},
									&ast.ReturnStmt{
										Return: c.newLine(),
										Results: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent("int64"),
												Args: []ast.Expr{
													&ast.BinaryExpr{
														X: &ast.CallExpr{
															Fun: ast.NewIdent("len"),
															Args: []ast.Expr{
																&ast.UnaryExpr{
																	Op: token.MUL,
																	X:  ast.NewIdent("r"),
																},
															},
														},
														Op: token.SUB,
														Y:  ast.NewIdent("l"),
													},
												},
											},
											ast.NewIdent("err"),
										},
									},
								},
							},
							&ast.CaseClause{
								List: []ast.Expr{
									&ast.UnaryExpr{
										Op: token.MUL,
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("byteio"),
											Sel: ast.NewIdent("MemBigEndian"),
										},
									},
								},
								Body: []ast.Stmt{
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("l"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent("len"),
												Args: []ast.Expr{
													&ast.UnaryExpr{
														Op: token.MUL,
														X:  ast.NewIdent("r"),
													},
												},
											},
										},
									},
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("err"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent(unmarshalName),
												Args: []ast.Expr{
													ast.NewIdent("t"),
													ast.NewIdent("r"),
												},
											},
										},
									},
									&ast.ReturnStmt{
										Return: c.newLine(),
										Results: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent("int64"),
												Args: []ast.Expr{
													&ast.BinaryExpr{
														X: &ast.CallExpr{
															Fun: ast.NewIdent("len"),
															Args: []ast.Expr{
																&ast.UnaryExpr{
																	Op: token.MUL,
																	X:  ast.NewIdent("r"),
																},
															},
														},
														Op: token.SUB,
														Y:  ast.NewIdent("l"),
													},
												},
											},
											ast.NewIdent("err"),
										},
									},
								},
							},
							&ast.CaseClause{
								List: []ast.Expr{
									&ast.UnaryExpr{
										Op: token.MUL,
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("byteio"),
											Sel: ast.NewIdent("StickyLittleEndianReader"),
										},
									},
								},
								Body: []ast.Stmt{
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("l"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.SelectorExpr{
												X:   ast.NewIdent("r"),
												Sel: ast.NewIdent("Count"),
											},
										},
									},
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											&ast.SelectorExpr{
												X:   ast.NewIdent("r"),
												Sel: ast.NewIdent("Err"),
											},
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: &ast.SelectorExpr{
													X:   ast.NewIdent("cmp"),
													Sel: ast.NewIdent("Or"),
												},
												Args: []ast.Expr{
													&ast.SelectorExpr{
														X:   ast.NewIdent("r"),
														Sel: ast.NewIdent("Err"),
													},
													&ast.CallExpr{
														Fun: ast.NewIdent(unmarshalName),
														Args: []ast.Expr{
															ast.NewIdent("t"),
															ast.NewIdent("r"),
														},
													},
												},
											},
										},
									},
									&ast.ReturnStmt{
										Return: c.newLine(),
										Results: []ast.Expr{
											&ast.BinaryExpr{
												X: &ast.SelectorExpr{
													X:   ast.NewIdent("r"),
													Sel: ast.NewIdent("Count"),
												},
												Op: token.SUB,
												Y:  ast.NewIdent("l"),
											},
											ast.NewIdent("err"),
										},
									},
								},
							},
							&ast.CaseClause{
								List: []ast.Expr{
									&ast.UnaryExpr{
										Op: token.MUL,
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("byteio"),
											Sel: ast.NewIdent("StickyBigEndianReader"),
										},
									},
								},
								Body: []ast.Stmt{
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("l"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.SelectorExpr{
												X:   ast.NewIdent("r"),
												Sel: ast.NewIdent("Count"),
											},
										},
									},
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											&ast.SelectorExpr{
												X:   ast.NewIdent("r"),
												Sel: ast.NewIdent("Err"),
											},
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: &ast.SelectorExpr{
													X:   ast.NewIdent("cmp"),
													Sel: ast.NewIdent("Or"),
												},
												Args: []ast.Expr{
													&ast.SelectorExpr{
														X:   ast.NewIdent("r"),
														Sel: ast.NewIdent("Err"),
													},
													&ast.CallExpr{
														Fun: ast.NewIdent(unmarshalName),
														Args: []ast.Expr{
															ast.NewIdent("t"),
															ast.NewIdent("r"),
														},
													},
												},
											},
										},
									},
									&ast.ReturnStmt{
										Return: c.newLine(),
										Results: []ast.Expr{
											&ast.BinaryExpr{
												X: &ast.SelectorExpr{
													X:   ast.NewIdent("r"),
													Sel: ast.NewIdent("Count"),
												},
												Op: token.SUB,
												Y:  ast.NewIdent("l"),
											},
											ast.NewIdent("err"),
										},
									},
								},
							},
						},
					},
				},
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						&ast.Ident{
							NamePos: c.newLine(),
							Name:    "sr",
						},
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CompositeLit{
							Type: &ast.SelectorExpr{
								X:   ast.NewIdent("byteio"),
								Sel: ast.NewIdent("StickyLittleEndianReader"),
							},
							Elts: []ast.Expr{
								&ast.KeyValueExpr{
									Key:   ast.NewIdent("Reader"),
									Value: ast.NewIdent("r"),
								},
							},
						},
					},
				},
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						ast.NewIdent("err"),
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("cmp"),
								Sel: ast.NewIdent("Or"),
							},
							Args: []ast.Expr{
								&ast.CallExpr{
									Fun: ast.NewIdent(unmarshalName),
									Args: []ast.Expr{
										ast.NewIdent("t"),
										&ast.UnaryExpr{
											Op: token.AND,
											X:  ast.NewIdent("sr"),
										},
									},
								},
								&ast.SelectorExpr{
									X:   ast.NewIdent("sr"),
									Sel: ast.NewIdent("Err"),
								},
							},
						},
					},
				},
				&ast.ReturnStmt{
					Return: c.newLine(),
					Results: []ast.Expr{
						&ast.SelectorExpr{
							X:   ast.NewIdent("sr"),
							Sel: ast.NewIdent("Count"),
						},
						ast.NewIdent("err"),
					},
				},
			},
		},
	}
}

func (c *constructor) readType(name ast.Expr, typ types.Type) {
	switch t := typ.Underlying().(type) {
	case *types.Struct:
		c.readStruct(name, t)
	case *types.Array:
		c.readArray(name, t)
	case *types.Slice:
		c.readSlice(name, t)
	case *types.Map:
		c.readMap(name, t)
	case *types.Pointer:
		c.readPointer(name, t)
	case *types.Basic:
		c.readBasic(name, t)
	}
}

func (c *constructor) addCall(fun *ast.SelectorExpr, name ast.Expr) {
	c.addStatement(&ast.ExprStmt{
		X: &ast.CallExpr{
			Fun:  fun,
			Args: []ast.Expr{name},
		},
	})
}

func (c *constructor) addReader(method string, name ast.Expr) {
	c.addStatement(&ast.AssignStmt{
		Lhs: []ast.Expr{name},
		Tok: token.ASSIGN,
		Rhs: []ast.Expr{
			&ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("r"),
					Sel: ast.NewIdent(method),
				},
			},
		},
	})
}

func (c *constructor) readStruct(name ast.Expr, t *types.Struct) {
	for field := range t.Fields() {
		if !field.Exported() {
			continue
		}

		c.readType(&ast.SelectorExpr{
			X:   name,
			Sel: ast.NewIdent(field.Name()),
		}, field.Type())
	}
}

func (c *constructor) readArray(name ast.Expr, t *types.Array) {
	d := c.subConstructor()

	d.readType(&ast.IndexExpr{
		X:     name,
		Index: ast.NewIdent("n"),
	}, t.Elem())
	c.addStatement(&ast.RangeStmt{
		For: c.newLine(),
		Key: ast.NewIdent("n"),
		Tok: token.DEFINE,
		X:   name,
		Body: &ast.BlockStmt{
			List: d.statements,
		},
	})
}

func (c *constructor) readSlice(name ast.Expr, t *types.Slice) {
	d := c.subConstructor()

	d.readType(&ast.IndexExpr{
		X:     name,
		Index: ast.NewIdent("n"),
	}, t.Elem())

	for _, stmt := range c.make(name, t.Elem()) {
		c.addStatement(stmt)
	}

	c.addStatement(&ast.RangeStmt{
		For: c.newLine(),
		Key: ast.NewIdent("n"),
		Tok: token.DEFINE,
		X:   name,
		Body: &ast.BlockStmt{
			List: d.statements,
		},
	})
}

func (c *constructor) make(name ast.Expr, t types.Type) []ast.Stmt {
	if named, ok := t.(*types.Named); ok && (named.Obj().Exported() || named.Obj().Pkg() == c.pkg || named.Obj().Pkg() == nil) {
		var ident ast.Expr

		if named.Obj().Pkg() == c.pkg || named.Obj().Pkg() == nil {
			ident = ast.NewIdent(named.Obj().Name())
		} else {
			ident = &ast.SelectorExpr{
				X:   ast.NewIdent(named.Obj().Pkg().Name()),
				Sel: ast.NewIdent(named.Obj().Name()),
			}
		}

		return []ast.Stmt{
			&ast.AssignStmt{
				Lhs: []ast.Expr{name},
				Tok: token.ASSIGN,
				Rhs: []ast.Expr{&ast.CallExpr{
					Fun: ast.NewIdent("make"),
					Args: []ast.Expr{
						&ast.ArrayType{
							Elt: ident,
						},
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("r"),
								Sel: ast.NewIdent("ReadUintX"),
							},
						},
					},
				}},
			},
		}
	}

	return []ast.Stmt{
		&ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{ast.NewIdent("l")},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("r"),
								Sel: ast.NewIdent("ReadUint64"),
							},
						},
					},
				},
				&ast.AssignStmt{
					Lhs: []ast.Expr{ast.NewIdent("x")},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X: &ast.CallExpr{
									Fun: &ast.SelectorExpr{
										X:   ast.NewIdent("reflect"),
										Sel: ast.NewIdent("ValueOf"),
									},
									Args: []ast.Expr{
										&ast.UnaryExpr{
											Op: token.AND,
											X:  name,
										},
									},
								},
								Sel: ast.NewIdent("Elem"),
							},
						},
					},
				},
				&ast.ExprStmt{
					X: &ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("x"),
							Sel: ast.NewIdent("Set"),
						},
						Args: []ast.Expr{
							&ast.CallExpr{
								Fun: &ast.SelectorExpr{
									X:   ast.NewIdent("reflect"),
									Sel: ast.NewIdent("MakeSlice"),
								},
								Args: []ast.Expr{
									&ast.CallExpr{
										Fun: &ast.SelectorExpr{
											X:   ast.NewIdent("x"),
											Sel: ast.NewIdent("Type"),
										},
									},
									ast.NewIdent("l"),
									ast.NewIdent("l"),
								},
							},
						},
					},
				},
			},
		},
	}
}

func (c *constructor) readMap(name ast.Expr, t *types.Map) {}

func (c *constructor) readPointer(name ast.Expr, t *types.Pointer) {
	d := c.subConstructor()

	for _, stmt := range c.new(name, t.Elem()) {
		d.addStatement(stmt)
	}

	d.readType(name, t.Elem())
	c.addStatement(&ast.IfStmt{
		Cond: &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("r"),
				Sel: ast.NewIdent("ReadBool"),
			},
		},
		Body: &ast.BlockStmt{
			List: d.statements,
		},
	})
}

func (c *constructor) new(name ast.Expr, t types.Type) []ast.Stmt {
	if named, ok := t.(*types.Named); ok && (named.Obj().Exported() || named.Obj().Pkg() == c.pkg || named.Obj().Pkg() == nil) {
		var ident ast.Expr

		if named.Obj().Pkg() == c.pkg || named.Obj().Pkg() == nil {
			ident = ast.NewIdent(named.Obj().Name())
		} else {
			ident = &ast.SelectorExpr{
				X:   ast.NewIdent(named.Obj().Pkg().Name()),
				Sel: ast.NewIdent(named.Obj().Name()),
			}
		}

		return []ast.Stmt{
			&ast.AssignStmt{
				Lhs: []ast.Expr{name},
				Tok: token.ASSIGN,
				Rhs: []ast.Expr{&ast.CallExpr{
					Fun:  ast.NewIdent("new"),
					Args: []ast.Expr{ident},
				}},
			},
		}
	}

	return []ast.Stmt{
		&ast.AssignStmt{
			Lhs: []ast.Expr{ast.NewIdent("x")},
			Tok: token.DEFINE,
			Rhs: []ast.Expr{
				&ast.CallExpr{
					Fun: &ast.SelectorExpr{
						X: &ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("reflect"),
								Sel: ast.NewIdent("ValueOf"),
							},
							Args: []ast.Expr{
								&ast.UnaryExpr{
									Op: token.AND,
									X:  name,
								},
							},
						},
						Sel: ast.NewIdent("Elem"),
					},
				},
			},
		},
		&ast.ExprStmt{
			X: &ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X:   ast.NewIdent("x"),
					Sel: ast.NewIdent("Set"),
				},
				Args: []ast.Expr{
					&ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("reflect"),
							Sel: ast.NewIdent("New"),
						},
						Args: []ast.Expr{
							&ast.CallExpr{
								Fun: &ast.SelectorExpr{
									X: &ast.CallExpr{
										Fun: &ast.SelectorExpr{
											X:   ast.NewIdent("x"),
											Sel: ast.NewIdent("Type"),
										},
									},
									Sel: ast.NewIdent("Elem"),
								},
							},
						},
					},
				},
			},
		},
	}
}

func (c *constructor) readBasic(name ast.Expr, t *types.Basic) {
	switch t.Kind() {
	case types.Bool:
		c.addReader("ReadBool", name)
	case types.Int:
		c.addReader("ReadInt64", name)
	case types.Int8:
		c.addReader("ReadInt8", name)
	case types.Int16:
		c.addReader("ReadInt16", name)
	case types.Int32:
		c.addReader("ReadInt32", name)
	case types.Int64:
		c.addReader("ReadInt64", name)
	case types.Uint:
		c.addReader("ReadUint64", name)
	case types.Uint8:
		c.addReader("ReadUint8", name)
	case types.Uint16:
		c.addReader("ReadUint16", name)
	case types.Uint32:
		c.addReader("ReadUint32", name)
	case types.Uint64, types.Uintptr:
		c.addReader("ReadUint64", name)
	case types.Float32:
		c.addReader("ReadFloat32", name)
	case types.Float64:
		c.addReader("ReadFloat64", name)
	case types.Complex64:
		c.addStatement(&ast.AssignStmt{
			Lhs: []ast.Expr{name},
			Tok: token.ASSIGN,
			Rhs: []ast.Expr{
				&ast.CallExpr{
					Fun: ast.NewIdent("complex"),
					Args: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("r"),
								Sel: ast.NewIdent("ReadFloat32"),
							},
						},
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("r"),
								Sel: ast.NewIdent("ReadFloat32"),
							},
						},
					},
				},
			},
		})
	case types.Complex128:
		c.addStatement(&ast.AssignStmt{
			Lhs: []ast.Expr{name},
			Tok: token.ASSIGN,
			Rhs: []ast.Expr{
				&ast.CallExpr{
					Fun: ast.NewIdent("complex"),
					Args: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("r"),
								Sel: ast.NewIdent("ReadFloat64"),
							},
						},
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("r"),
								Sel: ast.NewIdent("ReadFloat64"),
							},
						},
					},
				},
			},
		})
	case types.String:
		c.addReader("ReadStringX", name)
	}
}

func (c *constructor) unmarshalFunc(typ *types.Named) *ast.FuncDecl {
	typeName := typ.Obj().Name()
	unmarshalName := unmarshalName(typ)
	c.statements = nil

	c.readType(ast.NewIdent("t"), typ)

	return &ast.FuncDecl{
		Name: &ast.Ident{
			Name: unmarshalName,
		},
		Type: &ast.FuncType{
			Func: c.newLine(),
			TypeParams: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							ast.NewIdent("R"),
						},
						Type: &ast.SelectorExpr{
							X:   ast.NewIdent("byteio"),
							Sel: ast.NewIdent("StickyReader"),
						},
					},
				},
			},
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							ast.NewIdent("t"),
						},
						Type: &ast.UnaryExpr{
							Op: token.MUL,
							X:  ast.NewIdent(typeName),
						},
					},
					{
						Names: []*ast.Ident{
							ast.NewIdent("r"),
						},
						Type: ast.NewIdent("R"),
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: ast.NewIdent("error"),
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: append(c.statements, &ast.ReturnStmt{
				Results: []ast.Expr{
					ast.NewIdent("nil"),
				},
			}),
		},
	}
}
