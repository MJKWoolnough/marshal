package main

import (
	"go/ast"
	"go/format"
	"go/token"
	"io"
)

func constructFile(w io.Writer, pkg string) {
	fset := token.NewFileSet()
	lines := []int{0}
	newLine := func() token.Pos {
		l := len(lines)
		lines = append(lines, len(lines), len(lines)+1)

		return token.Pos(l + 1)
	}
	file := &ast.File{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Slash: newLine(),
					Text:  "//go:generate go run vimagination.zapto.org/marshal@latest --opts",
				},
			},
		},
		Name:    ast.NewIdent(pkg),
		Package: newLine(),
		Decls: []ast.Decl{
			&ast.GenDecl{
				Doc: &ast.CommentGroup{
					List: []*ast.Comment{
						{
							Slash: newLine(),
							Text:  "// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT",
						},
					},
				},
				TokPos: newLine(),
				Tok:    token.IMPORT,
				Specs: []ast.Spec{
					&ast.ImportSpec{
						Path: &ast.BasicLit{
							Kind:  token.STRING,
							Value: `"cmp"`,
						},
					},
					&ast.ImportSpec{
						Path: &ast.BasicLit{
							Kind:  token.STRING,
							Value: `"io"`,
						},
					},
					&ast.ImportSpec{
						Path: &ast.BasicLit{
							Kind:     token.STRING,
							Value:    `"vimagination.zapto.org/byteio"`,
							ValuePos: newLine(),
						},
					},
				},
			},
			&ast.FuncDecl{
				Recv: &ast.FieldList{
					List: []*ast.Field{
						{
							Names: []*ast.Ident{
								ast.NewIdent("t"),
							},
							Type: &ast.UnaryExpr{
								Op: token.MUL,
								X:  ast.NewIdent("Type"),
							},
						},
					},
				},
				Name: &ast.Ident{
					Name: "AppendBinary",
				},
				Type: &ast.FuncType{
					Params: &ast.FieldList{
						List: []*ast.Field{
							{
								Names: []*ast.Ident{
									ast.NewIdent("b"),
								},
								Type: &ast.ArrayType{
									Elt: ast.NewIdent("byte"),
								},
							},
						},
					},
					Results: &ast.FieldList{
						List: []*ast.Field{
							{
								Type: &ast.ArrayType{
									Elt: ast.NewIdent("byte"),
								},
							},
							{
								Type: ast.NewIdent("error"),
							},
						},
					},
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.AssignStmt{
							Lhs: []ast.Expr{
								ast.NewIdent("eb"),
							},
							Tok: token.DEFINE,
							Rhs: []ast.Expr{
								&ast.CallExpr{
									Fun: &ast.SelectorExpr{
										X:   ast.NewIdent("byteio"),
										Sel: ast.NewIdent("MemLittleEndian"),
									},
									Args: []ast.Expr{
										ast.NewIdent("b"),
									},
								},
							},
						},
						&ast.AssignStmt{
							Lhs: []ast.Expr{
								ast.NewIdent("err"),
							},
							Tok: token.DEFINE,
							Rhs: []ast.Expr{
								&ast.CallExpr{
									Fun: ast.NewIdent("_marshalType"),
									Args: []ast.Expr{
										ast.NewIdent("t"),
										&ast.UnaryExpr{
											Op: token.AND,
											X:  ast.NewIdent("eb"),
										},
									},
								},
							},
						},
						&ast.ReturnStmt{
							Return: newLine(),
							Results: []ast.Expr{
								ast.NewIdent("eb"),
								ast.NewIdent("err"),
							},
						},
					},
				},
			},
			&ast.FuncDecl{
				Recv: &ast.FieldList{
					List: []*ast.Field{
						{
							Names: []*ast.Ident{
								ast.NewIdent("t"),
							},
							Type: &ast.UnaryExpr{
								Op: token.MUL,
								X:  ast.NewIdent("Type"),
							},
						},
					},
				},
				Name: &ast.Ident{
					Name: "MarshalBinary",
				},
				Type: &ast.FuncType{
					Func:   newLine(),
					Params: &ast.FieldList{},
					Results: &ast.FieldList{
						List: []*ast.Field{
							{
								Type: &ast.ArrayType{
									Elt: ast.NewIdent("byte"),
								},
							},
							{
								Type: ast.NewIdent("error"),
							},
						},
					},
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.AssignStmt{
							Lhs: []ast.Expr{
								ast.NewIdent("eb"),
							},
							Tok: token.DEFINE,
							Rhs: []ast.Expr{
								&ast.CompositeLit{
									Type: &ast.SelectorExpr{
										X:   ast.NewIdent("byteio"),
										Sel: ast.NewIdent("MemLittleEndian"),
									},
								},
							},
						},
						&ast.AssignStmt{
							Lhs: []ast.Expr{
								ast.NewIdent("err"),
							},
							Tok: token.DEFINE,
							Rhs: []ast.Expr{
								&ast.CallExpr{
									Fun: ast.NewIdent("_marshalType"),
									Args: []ast.Expr{
										ast.NewIdent("t"),
										&ast.UnaryExpr{
											Op: token.AND,
											X:  ast.NewIdent("eb"),
										},
									},
								},
							},
						},
						&ast.ReturnStmt{
							Return: newLine(),
							Results: []ast.Expr{
								ast.NewIdent("eb"),
								ast.NewIdent("err"),
							},
						},
					},
				},
			},
			&ast.FuncDecl{
				Recv: &ast.FieldList{
					List: []*ast.Field{
						{
							Names: []*ast.Ident{
								ast.NewIdent("t"),
							},
							Type: &ast.UnaryExpr{
								Op: token.MUL,
								X:  ast.NewIdent("Type"),
							},
						},
					},
				},
				Name: &ast.Ident{
					Name: "WriteTo",
				},
				Type: &ast.FuncType{
					Func: newLine(),
					Params: &ast.FieldList{
						List: []*ast.Field{
							{
								Names: []*ast.Ident{
									ast.NewIdent("w"),
								},
								Type: &ast.SelectorExpr{
									X:   ast.NewIdent("io"),
									Sel: ast.NewIdent("Writer"),
								},
							},
						},
					},
					Results: &ast.FieldList{
						List: []*ast.Field{
							{
								Type: ast.NewIdent("int64"),
							},
							{
								Type: ast.NewIdent("error"),
							},
						},
					},
				},
				Body: &ast.BlockStmt{
					List: []ast.Stmt{
						&ast.TypeSwitchStmt{
							Assign: &ast.AssignStmt{
								Lhs: []ast.Expr{
									ast.NewIdent("w"),
								},
								Tok: token.DEFINE,
								Rhs: []ast.Expr{
									&ast.TypeAssertExpr{
										X: ast.NewIdent("w"),
									},
								},
							},
							Body: &ast.BlockStmt{
								List: []ast.Stmt{
									&ast.CaseClause{
										List: []ast.Expr{
											&ast.UnaryExpr{
												Op: token.MUL,
												X: &ast.SelectorExpr{
													X:   ast.NewIdent("byteio"),
													Sel: ast.NewIdent("MemLittleEndian"),
												},
											},
										},
										Body: []ast.Stmt{
											&ast.AssignStmt{
												Lhs: []ast.Expr{
													ast.NewIdent("l"),
												},
												Tok: token.DEFINE,
												Rhs: []ast.Expr{
													&ast.CallExpr{
														Fun: ast.NewIdent("len"),
														Args: []ast.Expr{
															&ast.UnaryExpr{
																Op: token.MUL,
																X:  ast.NewIdent("w"),
															},
														},
													},
												},
											},
											&ast.AssignStmt{
												Lhs: []ast.Expr{
													ast.NewIdent("err"),
												},
												Tok: token.DEFINE,
												Rhs: []ast.Expr{
													&ast.CallExpr{
														Fun: ast.NewIdent("_marshalType"),
														Args: []ast.Expr{
															ast.NewIdent("t"),
															ast.NewIdent("w"),
														},
													},
												},
											},
											&ast.ReturnStmt{
												Return: newLine(),
												Results: []ast.Expr{
													&ast.CallExpr{
														Fun: ast.NewIdent("int64"),
														Args: []ast.Expr{
															&ast.BinaryExpr{
																X: &ast.CallExpr{
																	Fun: ast.NewIdent("len"),
																	Args: []ast.Expr{
																		&ast.UnaryExpr{
																			Op: token.MUL,
																			X:  ast.NewIdent("w"),
																		},
																	},
																},
																Op: token.SUB,
																Y:  ast.NewIdent("l"),
															},
														},
													},
													ast.NewIdent("err"),
												},
											},
										},
									},
									&ast.CaseClause{
										List: []ast.Expr{
											&ast.UnaryExpr{
												Op: token.MUL,
												X: &ast.SelectorExpr{
													X:   ast.NewIdent("byteio"),
													Sel: ast.NewIdent("MemBigEndian"),
												},
											},
										},
										Body: []ast.Stmt{
											&ast.AssignStmt{
												Lhs: []ast.Expr{
													ast.NewIdent("l"),
												},
												Tok: token.DEFINE,
												Rhs: []ast.Expr{
													&ast.CallExpr{
														Fun: ast.NewIdent("len"),
														Args: []ast.Expr{
															&ast.UnaryExpr{
																Op: token.MUL,
																X:  ast.NewIdent("w"),
															},
														},
													},
												},
											},
											&ast.AssignStmt{
												Lhs: []ast.Expr{
													ast.NewIdent("err"),
												},
												Tok: token.DEFINE,
												Rhs: []ast.Expr{
													&ast.CallExpr{
														Fun: ast.NewIdent("_marshalType"),
														Args: []ast.Expr{
															ast.NewIdent("t"),
															ast.NewIdent("w"),
														},
													},
												},
											},
											&ast.ReturnStmt{
												Return: newLine(),
												Results: []ast.Expr{
													&ast.CallExpr{
														Fun: ast.NewIdent("int64"),
														Args: []ast.Expr{
															&ast.BinaryExpr{
																X: &ast.CallExpr{
																	Fun: ast.NewIdent("len"),
																	Args: []ast.Expr{
																		&ast.UnaryExpr{
																			Op: token.MUL,
																			X:  ast.NewIdent("w"),
																		},
																	},
																},
																Op: token.SUB,
																Y:  ast.NewIdent("l"),
															},
														},
													},
													ast.NewIdent("err"),
												},
											},
										},
									},
									&ast.CaseClause{
										List: []ast.Expr{
											&ast.UnaryExpr{
												Op: token.MUL,
												X: &ast.SelectorExpr{
													X:   ast.NewIdent("byteio"),
													Sel: ast.NewIdent("StickyLittleEndianWriter"),
												},
											},
										},
										Body: []ast.Stmt{
											&ast.AssignStmt{
												Lhs: []ast.Expr{
													ast.NewIdent("l"),
												},
												Tok: token.DEFINE,
												Rhs: []ast.Expr{
													&ast.SelectorExpr{
														X:   ast.NewIdent("w"),
														Sel: ast.NewIdent("Count"),
													},
												},
											},
											&ast.AssignStmt{
												Lhs: []ast.Expr{
													&ast.SelectorExpr{
														X:   ast.NewIdent("w"),
														Sel: ast.NewIdent("Err"),
													},
												},
												Tok: token.DEFINE,
												Rhs: []ast.Expr{
													&ast.CallExpr{
														Fun: &ast.SelectorExpr{
															X:   ast.NewIdent("cmp"),
															Sel: ast.NewIdent("Or"),
														},
														Args: []ast.Expr{
															&ast.SelectorExpr{
																X:   ast.NewIdent("w"),
																Sel: ast.NewIdent("Err"),
															},
															&ast.CallExpr{
																Fun: ast.NewIdent("_marshalType"),
																Args: []ast.Expr{
																	ast.NewIdent("t"),
																	ast.NewIdent("w"),
																},
															},
														},
													},
												},
											},
											&ast.ReturnStmt{
												Return: newLine(),
												Results: []ast.Expr{
													&ast.BinaryExpr{
														X: &ast.SelectorExpr{
															X:   ast.NewIdent("w"),
															Sel: ast.NewIdent("Count"),
														},
														Op: token.SUB,
														Y:  ast.NewIdent("l"),
													},
													ast.NewIdent("err"),
												},
											},
										},
									},
									&ast.CaseClause{
										List: []ast.Expr{
											&ast.UnaryExpr{
												Op: token.MUL,
												X: &ast.SelectorExpr{
													X:   ast.NewIdent("byteio"),
													Sel: ast.NewIdent("StickyBigEndianWriter"),
												},
											},
										},
										Body: []ast.Stmt{
											&ast.AssignStmt{
												Lhs: []ast.Expr{
													ast.NewIdent("l"),
												},
												Tok: token.DEFINE,
												Rhs: []ast.Expr{
													&ast.SelectorExpr{
														X:   ast.NewIdent("w"),
														Sel: ast.NewIdent("Count"),
													},
												},
											},
											&ast.AssignStmt{
												Lhs: []ast.Expr{
													&ast.SelectorExpr{
														X:   ast.NewIdent("w"),
														Sel: ast.NewIdent("Err"),
													},
												},
												Tok: token.DEFINE,
												Rhs: []ast.Expr{
													&ast.CallExpr{
														Fun: &ast.SelectorExpr{
															X:   ast.NewIdent("cmp"),
															Sel: ast.NewIdent("Or"),
														},
														Args: []ast.Expr{
															&ast.SelectorExpr{
																X:   ast.NewIdent("w"),
																Sel: ast.NewIdent("Err"),
															},
															&ast.CallExpr{
																Fun: ast.NewIdent("_marshalType"),
																Args: []ast.Expr{
																	ast.NewIdent("t"),
																	ast.NewIdent("w"),
																},
															},
														},
													},
												},
											},
											&ast.ReturnStmt{
												Return: newLine(),
												Results: []ast.Expr{
													&ast.BinaryExpr{
														X: &ast.SelectorExpr{
															X:   ast.NewIdent("w"),
															Sel: ast.NewIdent("Count"),
														},
														Op: token.SUB,
														Y:  ast.NewIdent("l"),
													},
													ast.NewIdent("err"),
												},
											},
										},
									},
								},
							},
						},
						&ast.AssignStmt{
							Lhs: []ast.Expr{
								&ast.Ident{
									NamePos: newLine(),
									Name:    "sw",
								},
							},
							Tok: token.DEFINE,
							Rhs: []ast.Expr{
								&ast.CompositeLit{
									Type: &ast.SelectorExpr{
										X:   ast.NewIdent("byteio"),
										Sel: ast.NewIdent("StickyLittleEndianWriter"),
									},
									Elts: []ast.Expr{
										&ast.KeyValueExpr{
											Key:   ast.NewIdent("Writer"),
											Value: ast.NewIdent("w"),
										},
									},
								},
							},
						},
						&ast.AssignStmt{
							Lhs: []ast.Expr{
								ast.NewIdent("err"),
							},
							Tok: token.DEFINE,
							Rhs: []ast.Expr{
								&ast.CallExpr{
									Fun: &ast.SelectorExpr{
										X:   ast.NewIdent("cmp"),
										Sel: ast.NewIdent("Or"),
									},
									Args: []ast.Expr{
										&ast.CallExpr{
											Fun: ast.NewIdent("_marshalType"),
											Args: []ast.Expr{
												ast.NewIdent("t"),
												&ast.UnaryExpr{
													Op: token.AND,
													X:  ast.NewIdent("sw"),
												},
											},
										},
										&ast.SelectorExpr{
											X:   ast.NewIdent("sw"),
											Sel: ast.NewIdent("Err"),
										},
									},
								},
							},
						},
						&ast.ReturnStmt{
							Return: newLine(),
							Results: []ast.Expr{
								&ast.SelectorExpr{
									X:   ast.NewIdent("sw"),
									Sel: ast.NewIdent("Count"),
								},
								ast.NewIdent("err"),
							},
						},
					},
				},
			},
		},
	}

	wsfile := fset.AddFile("out.go", 1, len(lines))

	wsfile.SetLines(lines)
	format.Node(w, fset, file)
}
