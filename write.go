package main

import (
	"go/ast"
	"go/format"
	"go/token"
	"io"
)

type pos []int

func (p *pos) newLine() token.Pos {
	l := len(*p)
	*p = append(*p, len(*p), len(*p)+1)

	return token.Pos(l + 1)
}

func constructFile(w io.Writer, pkg string) {
	fset := token.NewFileSet()
	lines := pos{0}
	file := &ast.File{
		Doc: &ast.CommentGroup{
			List: []*ast.Comment{
				{
					Slash: lines.newLine(),
					Text:  "//go:generate go run vimagination.zapto.org/marshal@latest --opts",
				},
			},
		},
		Name:    ast.NewIdent(pkg),
		Package: lines.newLine(),
		Decls: []ast.Decl{
			&ast.GenDecl{
				Doc: &ast.CommentGroup{
					List: []*ast.Comment{
						{
							Slash: lines.newLine(),
							Text:  "// THIS FILE IS GENERATED BY THE COMMAND AT THE TOP; DO NOT EDIT",
						},
					},
				},
				TokPos: lines.newLine(),
				Tok:    token.IMPORT,
				Specs: []ast.Spec{
					&ast.ImportSpec{
						Path: &ast.BasicLit{
							Kind:  token.STRING,
							Value: `"cmp"`,
						},
					},
					&ast.ImportSpec{
						Path: &ast.BasicLit{
							Kind:  token.STRING,
							Value: `"io"`,
						},
					},
					&ast.ImportSpec{
						Path: &ast.BasicLit{
							Kind:     token.STRING,
							Value:    `"vimagination.zapto.org/byteio"`,
							ValuePos: lines.newLine(),
						},
					},
				},
			},
			assignBinary(&lines),
			marshalBinary(&lines),
			writeTo(&lines),
			marshalFunc(&lines),
		},
	}

	wsfile := fset.AddFile("out.go", 1, len(lines))

	wsfile.SetLines(lines)
	format.Node(w, fset, file)
}

func assignBinary(lines *pos) *ast.FuncDecl {
	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						ast.NewIdent("t"),
					},
					Type: &ast.UnaryExpr{
						Op: token.MUL,
						X:  ast.NewIdent("Type"),
					},
				},
			},
		},
		Name: &ast.Ident{
			Name: "AppendBinary",
		},
		Type: &ast.FuncType{
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							ast.NewIdent("b"),
						},
						Type: &ast.ArrayType{
							Elt: ast.NewIdent("byte"),
						},
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.ArrayType{
							Elt: ast.NewIdent("byte"),
						},
					},
					{
						Type: ast.NewIdent("error"),
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						ast.NewIdent("eb"),
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("byteio"),
								Sel: ast.NewIdent("MemLittleEndian"),
							},
							Args: []ast.Expr{
								ast.NewIdent("b"),
							},
						},
					},
				},
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						ast.NewIdent("err"),
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: ast.NewIdent("_marshalType"),
							Args: []ast.Expr{
								ast.NewIdent("t"),
								&ast.UnaryExpr{
									Op: token.AND,
									X:  ast.NewIdent("eb"),
								},
							},
						},
					},
				},
				&ast.ReturnStmt{
					Return: lines.newLine(),
					Results: []ast.Expr{
						ast.NewIdent("eb"),
						ast.NewIdent("err"),
					},
				},
			},
		},
	}
}

func marshalBinary(lines *pos) *ast.FuncDecl {
	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						ast.NewIdent("t"),
					},
					Type: &ast.UnaryExpr{
						Op: token.MUL,
						X:  ast.NewIdent("Type"),
					},
				},
			},
		},
		Name: &ast.Ident{
			Name: "MarshalBinary",
		},
		Type: &ast.FuncType{
			Func:   lines.newLine(),
			Params: &ast.FieldList{},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: &ast.ArrayType{
							Elt: ast.NewIdent("byte"),
						},
					},
					{
						Type: ast.NewIdent("error"),
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						ast.NewIdent("eb"),
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CompositeLit{
							Type: &ast.SelectorExpr{
								X:   ast.NewIdent("byteio"),
								Sel: ast.NewIdent("MemLittleEndian"),
							},
						},
					},
				},
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						ast.NewIdent("err"),
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: ast.NewIdent("_marshalType"),
							Args: []ast.Expr{
								ast.NewIdent("t"),
								&ast.UnaryExpr{
									Op: token.AND,
									X:  ast.NewIdent("eb"),
								},
							},
						},
					},
				},
				&ast.ReturnStmt{
					Return: lines.newLine(),
					Results: []ast.Expr{
						ast.NewIdent("eb"),
						ast.NewIdent("err"),
					},
				},
			},
		},
	}
}

func writeTo(lines *pos) *ast.FuncDecl {
	return &ast.FuncDecl{
		Recv: &ast.FieldList{
			List: []*ast.Field{
				{
					Names: []*ast.Ident{
						ast.NewIdent("t"),
					},
					Type: &ast.UnaryExpr{
						Op: token.MUL,
						X:  ast.NewIdent("Type"),
					},
				},
			},
		},
		Name: &ast.Ident{
			Name: "WriteTo",
		},
		Type: &ast.FuncType{
			Func: lines.newLine(),
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							ast.NewIdent("w"),
						},
						Type: &ast.SelectorExpr{
							X:   ast.NewIdent("io"),
							Sel: ast.NewIdent("Writer"),
						},
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: ast.NewIdent("int64"),
					},
					{
						Type: ast.NewIdent("error"),
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.TypeSwitchStmt{
					Assign: &ast.AssignStmt{
						Lhs: []ast.Expr{
							ast.NewIdent("w"),
						},
						Tok: token.DEFINE,
						Rhs: []ast.Expr{
							&ast.TypeAssertExpr{
								X: ast.NewIdent("w"),
							},
						},
					},
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.CaseClause{
								List: []ast.Expr{
									&ast.UnaryExpr{
										Op: token.MUL,
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("byteio"),
											Sel: ast.NewIdent("MemLittleEndian"),
										},
									},
								},
								Body: []ast.Stmt{
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("l"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent("len"),
												Args: []ast.Expr{
													&ast.UnaryExpr{
														Op: token.MUL,
														X:  ast.NewIdent("w"),
													},
												},
											},
										},
									},
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("err"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent("_marshalType"),
												Args: []ast.Expr{
													ast.NewIdent("t"),
													ast.NewIdent("w"),
												},
											},
										},
									},
									&ast.ReturnStmt{
										Return: lines.newLine(),
										Results: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent("int64"),
												Args: []ast.Expr{
													&ast.BinaryExpr{
														X: &ast.CallExpr{
															Fun: ast.NewIdent("len"),
															Args: []ast.Expr{
																&ast.UnaryExpr{
																	Op: token.MUL,
																	X:  ast.NewIdent("w"),
																},
															},
														},
														Op: token.SUB,
														Y:  ast.NewIdent("l"),
													},
												},
											},
											ast.NewIdent("err"),
										},
									},
								},
							},
							&ast.CaseClause{
								List: []ast.Expr{
									&ast.UnaryExpr{
										Op: token.MUL,
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("byteio"),
											Sel: ast.NewIdent("MemBigEndian"),
										},
									},
								},
								Body: []ast.Stmt{
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("l"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent("len"),
												Args: []ast.Expr{
													&ast.UnaryExpr{
														Op: token.MUL,
														X:  ast.NewIdent("w"),
													},
												},
											},
										},
									},
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("err"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent("_marshalType"),
												Args: []ast.Expr{
													ast.NewIdent("t"),
													ast.NewIdent("w"),
												},
											},
										},
									},
									&ast.ReturnStmt{
										Return: lines.newLine(),
										Results: []ast.Expr{
											&ast.CallExpr{
												Fun: ast.NewIdent("int64"),
												Args: []ast.Expr{
													&ast.BinaryExpr{
														X: &ast.CallExpr{
															Fun: ast.NewIdent("len"),
															Args: []ast.Expr{
																&ast.UnaryExpr{
																	Op: token.MUL,
																	X:  ast.NewIdent("w"),
																},
															},
														},
														Op: token.SUB,
														Y:  ast.NewIdent("l"),
													},
												},
											},
											ast.NewIdent("err"),
										},
									},
								},
							},
							&ast.CaseClause{
								List: []ast.Expr{
									&ast.UnaryExpr{
										Op: token.MUL,
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("byteio"),
											Sel: ast.NewIdent("StickyLittleEndianWriter"),
										},
									},
								},
								Body: []ast.Stmt{
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("l"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.SelectorExpr{
												X:   ast.NewIdent("w"),
												Sel: ast.NewIdent("Count"),
											},
										},
									},
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											&ast.SelectorExpr{
												X:   ast.NewIdent("w"),
												Sel: ast.NewIdent("Err"),
											},
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: &ast.SelectorExpr{
													X:   ast.NewIdent("cmp"),
													Sel: ast.NewIdent("Or"),
												},
												Args: []ast.Expr{
													&ast.SelectorExpr{
														X:   ast.NewIdent("w"),
														Sel: ast.NewIdent("Err"),
													},
													&ast.CallExpr{
														Fun: ast.NewIdent("_marshalType"),
														Args: []ast.Expr{
															ast.NewIdent("t"),
															ast.NewIdent("w"),
														},
													},
												},
											},
										},
									},
									&ast.ReturnStmt{
										Return: lines.newLine(),
										Results: []ast.Expr{
											&ast.BinaryExpr{
												X: &ast.SelectorExpr{
													X:   ast.NewIdent("w"),
													Sel: ast.NewIdent("Count"),
												},
												Op: token.SUB,
												Y:  ast.NewIdent("l"),
											},
											ast.NewIdent("err"),
										},
									},
								},
							},
							&ast.CaseClause{
								List: []ast.Expr{
									&ast.UnaryExpr{
										Op: token.MUL,
										X: &ast.SelectorExpr{
											X:   ast.NewIdent("byteio"),
											Sel: ast.NewIdent("StickyBigEndianWriter"),
										},
									},
								},
								Body: []ast.Stmt{
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											ast.NewIdent("l"),
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.SelectorExpr{
												X:   ast.NewIdent("w"),
												Sel: ast.NewIdent("Count"),
											},
										},
									},
									&ast.AssignStmt{
										Lhs: []ast.Expr{
											&ast.SelectorExpr{
												X:   ast.NewIdent("w"),
												Sel: ast.NewIdent("Err"),
											},
										},
										Tok: token.DEFINE,
										Rhs: []ast.Expr{
											&ast.CallExpr{
												Fun: &ast.SelectorExpr{
													X:   ast.NewIdent("cmp"),
													Sel: ast.NewIdent("Or"),
												},
												Args: []ast.Expr{
													&ast.SelectorExpr{
														X:   ast.NewIdent("w"),
														Sel: ast.NewIdent("Err"),
													},
													&ast.CallExpr{
														Fun: ast.NewIdent("_marshalType"),
														Args: []ast.Expr{
															ast.NewIdent("t"),
															ast.NewIdent("w"),
														},
													},
												},
											},
										},
									},
									&ast.ReturnStmt{
										Return: lines.newLine(),
										Results: []ast.Expr{
											&ast.BinaryExpr{
												X: &ast.SelectorExpr{
													X:   ast.NewIdent("w"),
													Sel: ast.NewIdent("Count"),
												},
												Op: token.SUB,
												Y:  ast.NewIdent("l"),
											},
											ast.NewIdent("err"),
										},
									},
								},
							},
						},
					},
				},
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						&ast.Ident{
							NamePos: lines.newLine(),
							Name:    "sw",
						},
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CompositeLit{
							Type: &ast.SelectorExpr{
								X:   ast.NewIdent("byteio"),
								Sel: ast.NewIdent("StickyLittleEndianWriter"),
							},
							Elts: []ast.Expr{
								&ast.KeyValueExpr{
									Key:   ast.NewIdent("Writer"),
									Value: ast.NewIdent("w"),
								},
							},
						},
					},
				},
				&ast.AssignStmt{
					Lhs: []ast.Expr{
						ast.NewIdent("err"),
					},
					Tok: token.DEFINE,
					Rhs: []ast.Expr{
						&ast.CallExpr{
							Fun: &ast.SelectorExpr{
								X:   ast.NewIdent("cmp"),
								Sel: ast.NewIdent("Or"),
							},
							Args: []ast.Expr{
								&ast.CallExpr{
									Fun: ast.NewIdent("_marshalType"),
									Args: []ast.Expr{
										ast.NewIdent("t"),
										&ast.UnaryExpr{
											Op: token.AND,
											X:  ast.NewIdent("sw"),
										},
									},
								},
								&ast.SelectorExpr{
									X:   ast.NewIdent("sw"),
									Sel: ast.NewIdent("Err"),
								},
							},
						},
					},
				},
				&ast.ReturnStmt{
					Return: lines.newLine(),
					Results: []ast.Expr{
						&ast.SelectorExpr{
							X:   ast.NewIdent("sw"),
							Sel: ast.NewIdent("Count"),
						},
						ast.NewIdent("err"),
					},
				},
			},
		},
	}
}

func marshalFunc(lines *pos) *ast.FuncDecl {
	return &ast.FuncDecl{
		Name: &ast.Ident{
			Name: "_marshalType",
		},
		Type: &ast.FuncType{
			Func: lines.newLine(),
			TypeParams: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							ast.NewIdent("W"),
						},
						Type: &ast.SelectorExpr{
							X:   ast.NewIdent("byteio"),
							Sel: ast.NewIdent("StickyWriter"),
						},
					},
				},
			},
			Params: &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{
							ast.NewIdent("t"),
						},
						Type: &ast.UnaryExpr{
							Op: token.MUL,
							X:  ast.NewIdent("Type"),
						},
					},
					{
						Names: []*ast.Ident{
							ast.NewIdent("w"),
						},
						Type: ast.NewIdent("W"),
					},
				},
			},
			Results: &ast.FieldList{
				List: []*ast.Field{
					{
						Type: ast.NewIdent("error"),
					},
				},
			},
		},
		Body: &ast.BlockStmt{
			List: []ast.Stmt{
				&ast.ReturnStmt{
					Results: []ast.Expr{
						ast.NewIdent("nil"),
					},
				},
			},
		},
	}
}
